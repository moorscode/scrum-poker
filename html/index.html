<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>Pum Scroker!</title>
	<link href="/styles.css" rel="stylesheet">
	<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js"></script>
	<script src="/socket.io/socket.io.js"></script>
	<script src="https://kit.fontawesome.com/92b43d9045.js" crossorigin="anonymous"></script>
	<link rel="preconnect" href="https://fonts.gstatic.com">
	<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

<main id="v-app" :class="backgroundColor">
	<section class="poker">
		<h1>Pum Scroker</h1>

		<section v-if="!loading">
			<section v-if="!this.activePoker">
				<p>Welcome to Pum Scroker!</p>
				<p>This tool was created for scrum-teams to have a digital place where they can do their refinement.
					As many teams are working remotely due to the global COVID-19 situation.
				</p>
				<p>Join a room to start refining.</p>

				<form class="rooms">
					Room: <input type="text" v-model="joinPoker"/>
					<input type="submit" @click.prevent="joinRoom()" value="Join room!">
				</form>

				<p>
					<em>Suggestion: Prefix the room with your company name to ensure you are not
						competing for a room.</em>
				</p>
			</section>

			<div class="pokerMain" v-if="this.activePoker">

				<section v-if="refinementFinished">
					<h1 class="finished">Refinement done! ðŸ“£ ðŸ™Œ ðŸŽ‰</h1>
				</section>

				<section v-if="!refinementFinished">

					<div class="members-list-container">
						<button @click="showMembersList = !showMembersList" :class="showMembersList ? 'pressed' : ''"><i
								class="fas fa-clipboard-list"></i> Users ({{ members.voters.length
							}}/{{ members.observers.length }}/{{ members.disconnected.length }})
						</button>
						<div :class="['members-list', showMembersList ? '' : 'hidden']">
							<strong>Voters</strong>
							<ul>
								<li v-for="voter in members.voters">{{ voter.name }} <i class="fas fa-person-booth"></i>
								</li>
								<li v-if="!members.voters.length">None</li>
							</ul>
							<strong>Observers</strong>
							<ul>
								<li v-for="observer in members.observers">{{ observer.name }} <i
										class="fas fa-user-secret"></i></li>
								<li v-if="!members.observers.length">None</li>
							</ul>
							<strong>Disconnected</strong>
							<ul>
								<li v-for="disconnected in members.disconnected">{{ disconnected.name }} <i
										class="fas fa-plug disconnected"></i>
								</li>
								<li v-if="!members.disconnected.length">None</li>
							</ul>
						</div>
					</div>

					<form class="username" :class="[!nickname ? 'hover' : '']">
						<span><i class="fas fa-signature"></i> Nickname:</span>
						<input type="text" v-model="nickname"/>
						<input type="submit" @click.prevent="updateNickname" value="Update"/>
					</form>

					<div class="observe">
						<label>
							<input
									type="checkbox"
									v-model="observer"
									@change="observerChange()"/>
							{{ observing }}
						</label>
					</div>

					<button @click="newStory()" class="newStory" :disabled="voteCount === 0 || observer"><i
							class="fas fa-plus-square"></i>
						New story
					</button>
					<span class="allVoted" v-if="allVoted">All votes are in!</span>
					<button @click="refinementDone()" class="refinement-done"><i class="fas fa-clipboard-check"></i>
						Finish refinement
					</button>

					<hr/>

					<form>
						<label>Story name:
							<input type="text"
								   v-model="storyName"
								   :class="storyNameUpdated ? 'changed' : ''"
								   @keydown="storyNameUpdated = false"
								   v-on:change="storyNameUpdated = false"
							></label>
						<input type="submit" @click.prevent="setStoryName()" value="Update">
						<i v-if="storyNameUpdated" class="fas fa-check-circle story-updated"></i>
					</form>
					<br/>

					<div class="choices">
						<button
								v-for="point of points"
								@click="castVote(point)"
								:class="[
										'choice',
										pointIsPickedClass(point),
										myVote === point ? 'highlighted' : '',
										myInitialVote === point ? 'initial' : '',
									]"
						>
							<i :class="['fas','fa-mug-hot']" v-if="point === 'coffee'"></i>
							{{ point }}
						</button>
					</div>

					<hr/>

					<p :class="[ 'results', this.members.length === this.voteCount ? 'final' : '' ]">
						<span class="resultContainer" v-for="vote of votes">
							<button class="result initialVote" v-if="vote.initialValue !== vote.currentValue">
								<i :class="['fas','fa-mug-hot']" v-if="vote.initialValue === 'coffee'"></i>
								{{ vote.initialValue }}
							</button>
							<button class="result">
								<i :class="['fas','fa-mug-hot']" v-if="vote.currentValue === 'coffee'"></i>
								{{ vote.currentValue }}
								<div class="vote-names"
									 v-if="getGroupedVoteNames(vote)">
								{{ getGroupedVoteNames(vote).join(', ') }}
							</div>
							</button>
						</span>
						<div class="reveal-votes">
							<button @click="toggleRevealVotes()" :disabled="allVoted || nobodyVoted">
								<i :class="['fas',revealVotesButtonIconClass]"></i> {{revealVotesButtonText}}
							</button>
						</div>
					</p>

					<section v-if="average !== ''">
						<p>
							Average: {{ average }}<br/>
							Standard deviation: {{ standardDeviation }}<br/>
							<strong>Average story point: {{ averagePoint }}</strong>
						<p v-if="averageContext">
							<strong>{{ averageContext }}</strong>
						</p>
					</section>

					<div class="voting" v-if="unvotedNames.length > 0">
						<div class="voted">
							<strong><i class="far fa-check-circle"></i> Voted:</strong>
							<ul>
								<li v-for="name of votedNames">{{ name }}</li>
							</ul>
							<p v-if="votedNames.length === 0">Nobody voted yet.</p>
						</div>
						<div class="unvoted">
							<strong><i class="far fa-times-circle"></i> Not voted yet:</strong>
							<ul>
								<li v-for="name of unvotedNames">{{ name }}</li>
							</ul>
							<p v-if="unvotedNames.length === 0">Everybody voted!</p>
						</div>
					</div>
				</section>

				<div :class="['storyHistory', showHistory ? '':'hidden']">
					<h3 @click="toggleHistory()">Story history</h3>
					<section class="story">
						<button @click="resetHistory()" v-if="!observer" :disabled="storyHistory.length === 0"><i
								class="fas fa-eraser"></i>
							Reset history
						</button>
						<button @click="popHistory()" v-if="!observer" :disabled="storyHistory.length === 0"><i
								class="fas fa-backspace"></i>
							Delete last result
						</button>
						<section v-for="story of storyHistory">
							<strong>Story {{ story.name || 'result' }}: {{ story.nearestPointAverage }}</strong><br/>
							Votes:
							<ul>
								<li v-for="vote of story.votes">
									{{ vote.voterName }}:
									<span class="initialVote" v-if="vote.initialValue !== vote.currentValue">{{ vote.initialValue }}</span>
									<i v-if="vote.initialValue !== vote.currentValue"
									   :class="['fas','fa-arrow-right']"></i>
									{{ vote.currentValue }}
								</li>
							</ul>
						</section>
					</section>
				</div>
			</div>
		</section>
	</section>

	<section class="poker" v-if="!this.activePoker">
		<h2>Features</h2>
		<h3>Voting</h3>
		<p>
			You can vote to set what amount of points you think the current story is. You can change your vote
			while one or more member has not cast a vote yet. When everybody has voted, you cannot change your
			vote anymore unless you start a new story.
		</p>
		<p>
			Observers cannot vote.
		</p>
		<p>
			Voting for a coffee-break will short-circuit the results, requiring a re-vote after the break. The
			coffee-break is not added the history.
		</p>

		<p>
			Naming a story will make the history more usable.
			It is not required to name a story!
			Everybody can name or rename a story.
			A checkmark will show if the current name is the name registered for the story on the server.
		</p>

		<h3>Rooms</h3>
		<p>
			You can join a room by entering a room name in input box above, or you can add a `?room={your room}` to the
			URL to quickly go to that room. It is recommended to share the URL if you want teammembers to join your room
			easily.
		</p>

		<h3>Nickname</h3>
		<p>
			You can change your nickname at any time. The history will store the nickname you had at the moment when all
			votes were in. Your nickname is stored in your browser, to have it remembered when you come back the next
			time.
		</p>

		<h3>Observer-mode</h3>
		<p>
			While observing you cannot vote, start a new story or reset the history. You're just a fly on the
			wall. Observer-mode is stored on a per-room setting, so when you return to a room you'll automatically be
			set as an observer or as a regular member.
		</p>

		<h3>Story history</h3>
		<p>
			The story-history will be saved as long as there are members in the room. When a member uses the
			button to reset the history it will be gone from the room. The same counts when removing the last history
			item.
		</p>
	</section>

	<section class="credits">
		Build using <a href="https://nestjs.com/" target="_blank">NestJS</a>
		& <a href="https://vuejs.org/" target="_blank">Vue.js</a>
		- <a href="https://github.com/moorscode/scrum-poker/" target="_blank">source</a> on GPL 3.0+
		&mdash;
		<i class="fas fa-plug" :class="socket.connected ? 'connected':'disconnected'" title="Connection status"></i>
	</section>
</main>

<script>
	new Vue( {
		el: '#v-app',
		data: {
			socket: null,
			clientId: false,
			loading: true,
			refinementFinished: false,
			baseTitle: '',
			showMembersList: false,
			activePoker: false,
			joinPoker: '',
			currentStory: { name: '', nearestPointAverage: '', voteAverage: '' },
			points: {},
			nickname: '',
			observer: false,
			storyName: '',
			storyNameUpdated: false,
			myVote: '',
			myInitialVote: '',
			members: { voters: [], observers: [], disconnected: [] },
			votes: [],
			voteCount: 0,
			voteNames: {},
			votedNames: [],
			groupedVoterNames: [],
			showHistory: false,
			storyHistory: [],
		},
		methods: {
			refinementDone() {
				this.socket.emit( 'finish', { poker: this.activePoker } )
			},
			onRefinementDone() {
				this.refinementFinished = true
			},
			observerChange() {
				window.localStorage.setItem( this.activePoker + '-observer', this.observer )

				if ( this.observer ) {
					this.socket.emit( 'observe', { poker: this.activePoker } )
				} else {
					this.joinRoom()
				}
			},
			updateNickname() {
				if ( ! this.nickname ) {
					return
				}

				window.localStorage.setItem( 'nickname', this.nickname )
				this.socket.emit( 'nickname', { name: this.nickname, poker: this.activePoker } )
			},
			castVote( vote ) {
				if ( this.observer ) {
					return
				}

				if (this.allVoted && ! this.myInitialVote && this.myVote !== 'coffee') {
					this.myInitialVote = this.myVote;
				}

				this.myVote = vote
				this.socket.emit( 'vote', { poker: this.activePoker, vote: vote } )
			},
			setStoryName() {
				this.socket.emit( 'changeStoryName', { poker: this.activePoker, name: this.storyName } )
			},
			newStory() {
				if ( this.voteCount === 0 || this.observer ) {
					return
				}

				// Confirm when not everybody has voted.
				if ( this.voteCount !== this.members.voters.length ) {
					if ( ! window.confirm( 'Are you sure you want to start a new story, not all votes are in yet.' ) ) {
						return
					}
				}

				this.storyNameUpdated = false
				this.socket.emit( 'newStory', { poker: this.activePoker } )
			},
			resetHistory() {
				if ( ! window.confirm( 'Are you sure you want to clear the history?\n\nThis clears the history for all members in this room.' ) ) {
					return
				}
				this.socket.emit( 'resetHistory', { poker: this.activePoker } )
			},
			popHistory() {
				if ( ! window.confirm( 'Are you sure you want to remove the last history item?\n\nThis removes the item for all members in this room.' ) ) {
					return
				}
				this.socket.emit( 'popHistory', { poker: this.activePoker } )
			},
			toggleRevealVotes() {
				if ( ! this.currentStory.votesRevealed ) {
					if ( ! window.confirm( "Are you sure you want to reveal all votes before everybody has voted? Everybody can see the results." ) ) {
						return;
					}
				}
				this.socket.emit( 'toggleRevealVotes', { poker: this.activePoker } )
			},
			joinRoom() {
				this.joinPoker = this.joinPoker.toLowerCase()

				this.myVote = ''
				this.myInitialVote = ''
				this.voteCount = 0

				if ( this.joinPoker === '' ) {
					this.activePoker = ''
					return
				}

				this.socket.emit( 'join', { poker: this.joinPoker, name: this.nickname } )
			},
			toggleHistory() {
				this.showHistory = ! this.showHistory
				window.localStorage.setItem( 'showHistory', this.showHistory )
			},
			onJoined: function( msg ) {
				const currentPoker = this.activePoker
				this.activePoker = this.joinPoker = msg.poker
				this.myVote = ( msg.vote && msg.vote.currentValue ) || ''
				this.myInitialVote = ''

				if ( currentPoker !== false && currentPoker !== this.activePoker ) {
					const url = new URL( window.location )
					url.searchParams.set( 'room', this.activePoker )
					window.history.pushState( { room: this.activePoker }, '', url )
				}

				if ( this.observer ) {
					this.socket.emit( 'observe', { poker: this.activePoker } )
				}
			},
			onStoryHistory( msg ) {
				this.storyHistory = ( msg.stories || [] ).reverse()
			},
			onReceiveVote( msg ) {
				this.votes = msg.votes.sort( ( a, b ) => a.currentValue - b.currentValue ) || []
				this.voteCount = msg.voteCount
				this.votedNames = msg.votedNames || []
				this.groupedVoterNames = msg.groupedVoterNames || {}

				// Reset myVote when a new story is started.
				if ( this.voteCount === 0 ) {
					this.myVote = ''
					this.myInitialVote = ''
				}

				document.title = this.baseTitle + ' ' + this.voteCount + '/' + this.members.voters.length
			},
			onPoints( msg ) {
				this.points = msg.points
			},
			onPageChange( event ) {
				this.joinPoker = ( event.state && event.state.room ) || ''
				if ( this.joinPoker !== this.activePoker ) {
					this.socket.emit( 'leave', { poker: this.activePoker } )
				}
				this.joinRoom()
			},
			onStoryUpdated( msg ) {
				const nameChanged = ( this.currentStory.name !== msg.currentStory.name )
				this.currentStory = msg.currentStory;
				this.storyName = this.currentStory.name;

				if ( nameChanged ) {
					this.storyNameUpdated = true;
					setTimeout( () => this.storyNameUpdated = false, 1400 )
				}
			},
			onMemberList( msg ) {
				this.members = msg
			},
			getFromURL( key ) {
				return new URLSearchParams( window.location.search.substring( 1 ) ).get( key )
			},
			getGroupedVoteNames( vote ) {
				if ( ! this.groupedVoterNames ) {
					return [];
				}
				const voteGroupKey = vote.initialValue + "/" + vote.currentValue;
				return this.groupedVoterNames[ voteGroupKey ];
			},
			pointIsPickedClass( point ) {
				return this.votes.map( vote=>vote.currentValue ).includes( point ) ? 'picked' : '';
			},
		},
		computed: {
			unvotedNames() {
				const result = this.members.voters.map( member => member.name )
				for ( const name of this.votedNames ) {
					const index = result.indexOf( name )
					if ( index !== - 1 ) {
						result.splice( index, 1 )
					}
				}
				return result
			},
			observing() {
				return this.observer ? 'Observingâ€¦' : 'Observe'
			},
			average() {
				if ( this.voteCount === 0 || this.voteCount < this.members.voters.length ) {
					return ''
				}

				if ( this.currentStory.voteAverage === 'coffee' ) {
					return 'Coffee break'
				}

				return this.currentStory.voteAverage;
			},
			averageContext() {
				if ( this.average === '' ) {
					return ''
				}

				// Find the difference between the lowest and the highest votes.
				const lowestIndex = this.points.indexOf( this.votes[ 0 ].currentValue );
				const highestIndex = this.points.indexOf( this.votes[ this.votes.length - 1 ].currentValue );

				if ( highestIndex - lowestIndex > 2 ) {
					return `Large gap between lowest and highest vote: ${ highestIndex - lowestIndex } cards!`
				}
			},
			pointSpread() {
				if ( this.average === '' ) {
					return ''
				}

				// Find the difference between the lowest and the highest votes.
				const lowestIndex = this.points.indexOf( this.votes[ 0 ].currentValue )
				const highestIndex = this.points.indexOf( this.votes[ this.votes.length - 1 ].currentValue )

				return highestIndex - lowestIndex
			},
			backgroundColor() {
				switch ( true ) {
					case this.refinementFinished:
						return 'finished'
					case this.pointSpread === '':
						return ''
					case this.pointSpread === 0:
						return 'no-spread'
					case this.pointSpread > 2:
						return 'high-spread'
					default:
						return 'normal-spread'
				}
			},
			standardDeviation() {
				if ( this.average === '' ) {
					return ''
				}

				if ( this.votes.length <= 1 || this.votes.map( vote => vote.currentValue ).indexOf( 'coffee' ) !== - 1 ) {
					return 'n/a'
				}

				let powers = 0
				for ( let i = 0; i < this.votes.length; i ++ ) {
					powers += Math.pow( parseFloat( this.votes.map( vote => vote.currentValue )[ i ] ) - this.average, 2 )
				}

				return Math.round( Math.sqrt( powers / this.votes.length ) * 100 ) / 100
			},
			averagePoint() {
				if ( this.average === '' ) {
					return ''
				}

				return this.currentStory.nearestPointAverage;
			},
			allVoted() {
				return this.members.voters.length && this.voteCount === this.members.voters.length;
			},
			nobodyVoted() {
				return this.voteCount === 0;
			},
			revealVotesButtonIconClass() {
				return this.currentStory.votesRevealed ? 'fa-eye-slash' :'fa-eye';
			},
			revealVotesButtonText() {
				return this.currentStory.votesRevealed ? 'Hide votes' :'Reveal votes';
			}
		},
		created() {
			this.baseTitle = document.title

			this.joinPoker = this.getFromURL( 'room' ) || ''

			// Retrieve data from local storage.
			this.nickname = window.localStorage.getItem( 'nickname' )
			this.showHistory = window.localStorage.getItem( 'showHistory' ) === 'true'
			if ( this.joinPoker ) {
				this.observer = window.localStorage.getItem( this.joinPoker + '-observer' ) === 'true'
			}

			const clientId = window.localStorage.getItem( 'clientId' )
			if ( clientId && clientId !== '' && ! this.getFromURL( 'new-client' ) ) {
				this.clientId = clientId
			}

			this.socket = io( window.location.protocol + '//' + window.location.hostname + ':' + location.port + window.location.pathname + 'pokers' )

			this.socket.on( 'userId', ( clientId ) => {
				if ( ! this.clientId ) {
					this.clientId = clientId
				}
				window.localStorage.setItem( 'clientId', this.clientId )
				this.socket.emit( 'identify', { id: this.clientId } )
			} )

			this.socket.on( 'welcome', this.joinRoom )
			this.socket.on( 'reconnect', () => {
				this.socket.emit( 'identify', { id: this.clientId } )
			} )

			this.socket.on( 'points', ( msg ) => {
				this.onPoints( msg )
				this.loading = false
			} )

			this.socket.on( 'joined', this.onJoined )
			this.socket.on( 'votes', this.onReceiveVote )
			this.socket.on( 'history', this.onStoryHistory )
			this.socket.on( 'storyUpdated', this.onStoryUpdated )
			this.socket.on( 'member-list', this.onMemberList )
			this.socket.on( 'finished', this.onRefinementDone )

			window.onpopstate = this.onPageChange
			window.onbeforeunload = () => {
				this.socket.emit( 'exit' )
			}
		}
	} );
</script>
</body>
</html>
